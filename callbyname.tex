\documentclass[10pt]{beamer}

\usetheme[progressbar=frametitle]{metropolis}
\usepackage{appendixnumberbeamer}
\usepackage[sfdefault]{FiraSans}
\usepackage{FiraMono}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}

\usepackage{pgfplots}
\usepgfplotslibrary{dateplot}

\usepackage{listings}

\usepackage{tikz}

\usepackage{xspace}
\newcommand{\themename}{\textbf{\textsc{metropolis}}\xspace}

%%% Relevant videos
% https://www.youtube.com/watch?v=NX7D5eEh2n0
%

%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% UNCC Theme Adjustments %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\definecolor{CanvasBG}{HTML}{FAFAFA}

% From the official style guide
\definecolor{UnccGreen}{HTML}{00703C}
\definecolor{UnccGold}{HTML}{B3A369}
\definecolor{UnccLightGreen}{HTML}{C3D7A4}
\definecolor{UnccYellow}{HTML}{F0CB00}
\definecolor{UnccOrange}{HTML}{F3901D}
\definecolor{UnccLightYellow}{HTML}{FFF6DC}
\definecolor{UnccBlue}{HTML}{00728F}
\definecolor{UnccPink}{HTML}{DE3A6E}
\definecolor{White}{HTML}{FFFFFF}
\definecolor{LightGray}{HTML}{DDDDDD}

% Supporting Color Palette
\definecolor{WarmGray}{HTML}{696158}
\definecolor{StoneGray}{HTML}{717C7D}
\definecolor{DarkGreen}{HTML}{2C5234}
\definecolor{LightGreen}{HTML}{509E2F}
\definecolor{BrightGold}{HTML}{F0CB00}

% Screamers
\definecolor{Royal}{HTML}{72246C}
\definecolor{Ocean}{HTML}{006BA6}
\definecolor{Flash}{HTML}{B52555}
\definecolor{Citrus}{HTML}{FFB81C}
\definecolor{Spring}{HTML}{CEDC00}

% Serenity
\definecolor{Garden}{HTML}{B7CE95}
\definecolor{Sand}{HTML}{F0E991}
\definecolor{Bloom}{HTML}{F1E6B2}
\definecolor{Clay}{HTML}{B7B09C}
\definecolor{Cloud}{HTML}{BAC5B9}

% Set colors here
\setbeamercolor{frametitle}{bg=UnccGreen}
\setbeamercolor{progress bar}{bg=BrightGold, fg=UnccGreen}
\setbeamercolor{alerted text}{fg=Flash}

\setbeamercolor{block title}{bg=LightGreen, fg=White}
\setbeamercolor{block title example}{bg=Ocean, fg=White}
\setbeamercolor{block title alerted}{bg=Citrus, fg=White}
\setbeamercolor{block body}{bg=CanvasBG}

\metroset{titleformat=smallcaps, progressbar=foot}

\makeatletter
\setlength{\metropolis@progressinheadfoot@linewidth}{2pt}
\setlength{\metropolis@titleseparator@linewidth}{2pt}
\setlength{\metropolis@progressonsectionpage@linewidth}{2pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% UNCC Theme Adjustments %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\lstset{
  basicstyle=\scriptsize\ttfamily,
  keywordstyle=\color{Ocean},
  stringstyle=,
  xleftmargin=1em,
  showstringspaces=false,
  commentstyle=\itshape\rmfamily,
  columns=flexible,
  keepspaces=true,
  texcl=true
}
\lstset{escapeinside={<@}{@>}}

% https://www.mathcha.io/editor

\title{Call-by-name, Call-by-value, Call-by-need, and the Linear Lambda Calculus}
% subtitle:
\subtitle{Short Talk}

% \date{\today}
\date{}
\author{Quentin Schroeder}
\institute{MPRI - Université Paris-Cité}
\titlegraphic{\hfill\includegraphics[height=1.5cm]{logo.pdf}}

\begin{document}

\maketitle

% Outline
% 1. Motivation - why do we care about evaluation strategies
% 2. Preliminaries - introduce the lambda calculus and the two evaluation strategies
% 3. Call by Name - explain the evaluation strategy and its properties
% 4. Call by Name - give examples in the lambda calculus
% 5. Detour: Call by Need - explain the evaluation strategy and its properties
% 6. Detour: Call by Need - give examples in haskell
% 7. Call by Value - explain the evaluation strategy and its properties
% 8. Call by Value - give examples in Ocaml

\section[Idea]{Motivation}

% give two code examples
% one is a place where call by name is better
% one is a place where call by value is better
% explain the difference between the two

% then give code examples in ocaml vs haskell to compare call by need and call by value

\begin{frame}[fragile]{Motivation}
  \begin{alertblock}{Problem}
    We want to understand how to evaluate expressions in the lambda calculus.\\
    % enumerate with alerts
  \end{alertblock}

  \begin{itemize} [<+- | alert@+>]
    \item Call by Name
    \item Call by Value
    \item Call by Need
  \end{itemize}
\end{frame}


\begin{frame}[fragile]{Call by value (Ocaml)}
  \begin{alertblock}{Examples}
  \begin{lstlisting}[language=Caml, literate={_}{\_}{1}]
    let rec dumb_works n = if (n = 0 && n = 1) then dumb n else 42

    let () = print_int (dumb_works 0)

  \end{lstlisting}
  \pause
  \begin{lstlisting}[language=Caml, literate={_}{\_}{1}]

    let branch b l r = if b then l else r

    let rec dumb_breaks n = branch (n = 0 && n = 1) (dumb_breaks n) 42


    let () = print_int (dumb_breaks 0)

  \end{lstlisting}
  \end{alertblock}
\end{frame}


\begin{frame}[fragile]{Call by need (Haskell)}
  \begin{alertblock}{Example}
  \begin{lstlisting}[language=Haskell]
    dumb n = if (n == 0 && n == 1) then dumb n else 42

    forceEvalBranch b l r = if b then l else r

    dumb2 n = forceEvalBranch (n == 0 && n == 1) (dumb2 n) 42

    main = do
        print $ dumb 0
        print $ dumb 1
        print $ dumb2 0
        print $ dumb2 1

  \end{lstlisting}
  \end{alertblock}

  \pause

  \begin{alertblock}{Example}
  \begin{lstlisting}[language=Haskell]
    project x y = x

    loop x = loop x

    main = print $ project 2 (loop 3)
  \end{lstlisting}
  \end{alertblock}


\end{frame}

\begin{frame}[fragile]{Call by Name (???)}
  \begin{alertblock}{Is there a call by name programming language?}
    Yes \dots kind of (e.g. Algol 60)
  \end{alertblock}

  \begin{alertblock}{Example}
    Consider the following:
  \begin{lstlisting}[language=Caml, literate={_}{\_}{1}]
    let rec horrible n = if n = 0 then 1 else n * horrible (n - 1) * horrible (n - 1)

    let printalot m =
      let () = print_endline (string_of_int m) in
      let () = print_endline (string_of_int m) in
      let () = print_endline (string_of_int m) in
      let () = print_endline (string_of_int m)

    let () = printNTimes (horrible 40)

  \end{lstlisting}
  \end{alertblock}
\end{frame}

\section[Preliminaries]{How formally interpret these?}

\begin{frame}[fragile]{Preliminaries}
  \begin{alertblock}{Lambda Calculus}
    \begin{itemize}
      \item model of computation
      \item basis for functional programming languages
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]{Preliminaries}
  \begin{alertblock}{Linear Logic}
    \begin{itemize}
      \item a resource sensitive logic
      \item can be used to priority in evaluation of proof terms
    \end{itemize}
  \end{alertblock}

  \pause

  \begin{alertblock}{A massive leap of faith}
    \begin{itemize}
      \item build a linear lambda calculus \cite[]{Maraist1995Jan}
      \item show that it can be used to model execution strategies
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}
  \begin{alertblock}{Why do we care?}
    \begin{itemize}
      \item learn about the underlying structure of evaluation strategies
      \item learn how to improve our current programming languages (e.g. Rust)
      \item learn about them as models for complexity theory \cite[]{10.1145/3371095}
    \end{itemize}
  \end{alertblock}
\end{frame}


\begin{frame}[fragile]{Interpretation of Call by Value}
  \begin{alertblock}{Call by Value}
    \begin{itemize}
      \item evaluate the argument before the function
      \item the argument is evaluated at most once
    \end{itemize}
  \end{alertblock}

  \pause

  \begin{alertblock}{Call by Value via "suspending computation"}
    \begin{itemize}
      \item suspend computation of all the innermost functions calls
      \item evaluate from last to first
    \end{itemize}
  \end{alertblock}

\end{frame}

  \begin{frame}[fragile]{Interpretation of Call by Value}

  \begin{alertblock}{Example}
    \begin{lstlisting}[language=Caml, literate={_}{\_}{1}]
      let f x y = x + y
      let () = print_int (f (1 + 2) (3 + 4))

    \end{lstlisting}

    \pause

    \begin{itemize} [<+- | alert@+>]
      \item evaluate \texttt{f (1 + 2) (3 + 4)}
      \item evaluate \texttt{1 + 2}
      \item evaluate \texttt{3 + 4}
      \item evaluate \texttt{f 3 7}
      \item evaluate \texttt{3 + 7}
      \item print \texttt{10}
    \end{itemize}

    \pause

    For the suspend interpretation: we would view this as blocking evaluation of \texttt{f} until the arguments are evaluated.
  \end{alertblock}
\end{frame}









% overview slide



\section{Conclusion}

\begin{frame}[fragile]{Conclusion}
  \begin{alertblock}{In short}
    \begin{itemize}
      \item Call by Name
      \item Call by Value
      \item Call by Need
    \end{itemize}
  \end{alertblock}

  \begin{alertblock}{For the next time}
    \begin{itemize}
      \item Model Call by Name and Call by Need in this model
      \item Show interpretations have nice properties (soundness, completeness, etc.)
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[standout]
  Thank you
\end{frame}

\begin{frame}[allowframebreaks]{References}
  \bibliographystyle{plainnat}
  \bibliography{sources}
\end{frame}



\end{document}
